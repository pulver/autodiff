<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.Autodiff: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boost.Autodiff
   </div>
   <div id="projectbrief">Automatic Differentiation C++ Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Boost.Autodiff Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="synopsis"></a>
Synopsis</h1>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/math/differentiation/autodiff.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>math { <span class="keyword">namespace </span>differentiation { <span class="keyword">namespace </span>autodiff {</div><div class="line"></div><div class="line"><span class="comment">// The primary template alias for instantiating autodiff variables.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RealType,<span class="keywordtype">size_t</span> Order,<span class="keywordtype">size_t</span>... Orders&gt;</div><div class="line"><span class="keyword">using</span> variable = <span class="keyword">typename</span> nested_dimensions&lt;RealType,Order,Orders...&gt;::type;</div><div class="line"></div><div class="line"><span class="comment">// Satisfies Boost&#39;s Conceptual Requirements for Real Number Types.</span></div><div class="line"><span class="comment">// Don&#39;t use this dimension&lt;&gt; class directly. Instead, use the variable&lt;&gt; alias.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RealType,<span class="keywordtype">size_t</span> Order&gt;</div><div class="line"><span class="keyword">class </span>dimension</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="comment">// Initialize a variable of differentiation.</span></div><div class="line">    <span class="keyword">explicit</span> dimension(<span class="keyword">const</span> root_type&amp;);</div><div class="line"></div><div class="line">    <span class="comment">// The root data type chosen when variable&lt;&gt; is declared. E.g. float, double, etc.</span></div><div class="line">    <span class="keyword">explicit</span> <span class="keyword">operator</span> root_type() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Query return value of computation to get the derivatives.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Orders&gt;</div><div class="line">    <span class="keyword">typename</span> type_at&lt;RealType,<span class="keyword">sizeof</span>...(Orders)-1&gt;::type derivative(Orders... orders) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// All of the arithmetic operators are overloaded.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> RealType2,<span class="keywordtype">size_t</span> Order2&gt;</div><div class="line">    dimension&lt;RealType,Order&gt;&amp; operator+=(<span class="keyword">const</span> dimension&lt;RealType2,Order2&gt;&amp;);</div><div class="line"></div><div class="line">    dimension&lt;RealType,Order&gt;&amp; operator+=(<span class="keyword">const</span> root_type&amp;);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Standard math functions are overloaded and called via argument-dependent lookup (ADL).</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RealType,<span class="keywordtype">size_t</span> Order&gt;</div><div class="line">dimension&lt;RealType,Order&gt; floor(<span class="keyword">const</span> dimension&lt;RealType,Order&gt;&amp;);</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RealType,<span class="keywordtype">size_t</span> Order&gt;</div><div class="line">dimension&lt;RealType,Order&gt; exp(<span class="keyword">const</span> dimension&lt;RealType,Order&gt;&amp;);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">} } } } <span class="comment">// namespace boost::math::differentiation::autodiff</span></div><div class="line"></div></div><!-- fragment --></p>
<h1><a class="anchor" id="description"></a>
Description</h1>
<p>Autodiff is a header-only C++ library that facilitates the <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> (forward mode) of mathematical functions in single and multiple variables.</p>
<h2><a class="anchor" id="requirements"></a>
Requirements</h2>
<ol type="1">
<li>C++11 compiler. Visual Studio 2015 is not supported.</li>
<li>Maximum derivative orders are set at compile-time. This allows for compile-time allocation of memory with <code>std::array&lt;&gt;</code>, so that use of dynamic memory is avoided.</li>
<li>Mathematical functions should accept generic types (template variables) for the variables that derivatives are calculated with respect to.</li>
</ol>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<h2><a class="anchor" id="example-single-variable"></a>
Example 1: Single-variable derivatives</h2>
<h3>Calculate derivatives of \(f(x)=x^4\) at \(x=2.0\).</h3>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/math/differentiation/autodiff.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T fourth_power(T x)</div><div class="line">{</div><div class="line">    x *= x;</div><div class="line">    <span class="keywordflow">return</span> x *= x;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1math_1_1differentiation.html">boost::math::differentiation</a>;</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">int</span> Order=5; <span class="comment">// The highest order derivative to be calculated.</span></div><div class="line">    <span class="keyword">const</span> autodiff::variable&lt;double,Order&gt; x(2.0); <span class="comment">// Find derivatives at x=2.</span></div><div class="line">    <span class="keyword">const</span> autodiff::variable&lt;double,Order&gt; y = fourth_power(x);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0 ; i&lt;=Order ; ++i)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;y.derivative(&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;) = &quot;</span> &lt;&lt; y.derivative(i) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Compile:</span></div><div class="line"><span class="comment">$ g++ -std=c++1z example/fourth_power.cpp</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Output:</span></div><div class="line"><span class="comment">$ ./a.out</span></div><div class="line"><span class="comment">y.derivative(0) = 16</span></div><div class="line"><span class="comment">y.derivative(1) = 32</span></div><div class="line"><span class="comment">y.derivative(2) = 48</span></div><div class="line"><span class="comment">y.derivative(3) = 48</span></div><div class="line"><span class="comment">y.derivative(4) = 24</span></div><div class="line"><span class="comment">y.derivative(5) = 0</span></div><div class="line"><span class="comment">**/</span></div></div><!-- fragment --></p>
<p>The above calculates </p><p class="formulaDsp">
\begin{alignat*}{3} {\tt y.derivative(0)} &amp;=&amp; f(2) =&amp;&amp; \left.x^4\right|_{x=2} &amp;= 16\\ {\tt y.derivative(1)} &amp;=&amp; f&#39;(2) =&amp;&amp; \left.4\cdot x^3\right|_{x=2} &amp;= 32\\ {\tt y.derivative(2)} &amp;=&amp; f&#39;&#39;(2) =&amp;&amp; \left.4\cdot 3\cdot x^2\right|_{x=2} &amp;= 48\\ {\tt y.derivative(3)} &amp;=&amp; f&#39;&#39;&#39;(2) =&amp;&amp; \left.4\cdot 3\cdot2\cdot x\right|_{x=2} &amp;= 48\\ {\tt y.derivative(4)} &amp;=&amp; f^{(4)}(2) =&amp;&amp; 4\cdot 3\cdot2\cdot1 &amp;= 24\\ {\tt y.derivative(5)} &amp;=&amp; f^{(5)}(2) =&amp;&amp; 0 &amp; \end{alignat*}
</p>
<hr/>
<h2><a class="anchor" id="example-multiprecision"></a>
Example 2: Multi-variable mixed partial derivatives with multi-precision data type</h2>
<h3>Calculate \(\frac{\partial^{12}f}{\partial w^{3}\partial x^{2}\partial y^{4}\partial z^{3}}(11,12,13,14)\) with a precision of about 100 decimal digits, where \(f(w,x,y,z)=\exp\left(w\sin\left(\frac{x\log(y)}{z}\right)+\sqrt{\frac{wz}{xy}}\right)+\frac{w^2}{\tan(z)}\).</h3>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/math/differentiation/autodiff.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/multiprecision/cpp_dec_float.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T f(<span class="keyword">const</span> T&amp; w, <span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y, <span class="keyword">const</span> T&amp; z)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line">  <span class="keywordflow">return</span> exp(w*sin(x*log(y)/z) + sqrt(w*z/(x*y))) + w*w/tan(z);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> cpp_dec_float_100 = boost::multiprecision::cpp_dec_float_100;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1math_1_1differentiation.html">boost::math::differentiation</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Calculated from Mathematica symbolic differentiation. See multiprecision.nb for script.</span></div><div class="line">  <span class="keyword">const</span> cpp_dec_float_100 answer(<span class="stringliteral">&quot;1976.31960074779771777988187529041872090812118921875499076582535951111845769110560421820940516423255314&quot;</span>);</div><div class="line">  constexpr <span class="keywordtype">int</span> Nw=3; <span class="comment">// Max order of derivative to calculate for w</span></div><div class="line">  constexpr <span class="keywordtype">int</span> Nx=2; <span class="comment">// Max order of derivative to calculate for x</span></div><div class="line">  constexpr <span class="keywordtype">int</span> Ny=4; <span class="comment">// Max order of derivative to calculate for y</span></div><div class="line">  constexpr <span class="keywordtype">int</span> Nz=3; <span class="comment">// Max order of derivative to calculate for z</span></div><div class="line">  <span class="keyword">using</span> var = autodiff::variable&lt;cpp_dec_float_100,Nw,Nx,Ny,Nz&gt;;</div><div class="line">  <span class="keyword">const</span> var w = autodiff::variable&lt;cpp_dec_float_100,Nw&gt;(11);</div><div class="line">  <span class="keyword">const</span> var x = autodiff::variable&lt;cpp_dec_float_100,0,Nx&gt;(12);</div><div class="line">  <span class="keyword">const</span> var y = autodiff::variable&lt;cpp_dec_float_100,0,0,Ny&gt;(13);</div><div class="line">  <span class="keyword">const</span> var z = autodiff::variable&lt;cpp_dec_float_100,0,0,0,Nz&gt;(14);</div><div class="line">  <span class="keyword">const</span> var v = f(w,x,y,z);</div><div class="line">  std::cout &lt;&lt; std::setprecision(std::numeric_limits&lt;cpp_dec_float_100&gt;::digits10)</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;mathematica   : &quot;</span> &lt;&lt; answer &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff      : &quot;</span> &lt;&lt; v.derivative(Nw,Nx,Ny,Nz) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;relative error: &quot;</span> &lt;&lt; std::setprecision(3) &lt;&lt; (v.derivative(Nw,Nx,Ny,Nz)/answer-1) &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Compile:</span></div><div class="line"><span class="comment">$ g++ -std=c++1z example/multiprecision.cpp</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Output:</span></div><div class="line"><span class="comment">$ ./a.out</span></div><div class="line"><span class="comment">mathematica   : 1976.319600747797717779881875290418720908121189218754990765825359511118457691105604218209405164232553</span></div><div class="line"><span class="comment">autodiff      : 1976.319600747797717779881875290418720908121189218754990765825359511118457691105604218209405164232566</span></div><div class="line"><span class="comment">relative error: 6.47e-99</span></div><div class="line"><span class="comment">**/</span></div></div><!-- fragment --></p>
<hr/>
<h2><a class="anchor" id="example-black-scholes"></a>
Example 3: Black-Scholes option pricing</h2>
<h3>Using the standard Black-Scholes model for pricing European options, calculate call/put prices and greeks.</h3>
<p><a href="https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks">https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks</a></p>
<p>One of the primary benefits of using automatic differentiation is the elimination of additional functions to calculate derivatives, which is a form of code redundancy.  <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/math/differentiation/autodiff.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Equations and function/variable names are from</span></div><div class="line"><span class="comment">// https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks</span></div><div class="line"></div><div class="line"><span class="comment">// Standard normal probability density function</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</div><div class="line">X phi(<span class="keyword">const</span> X&amp; x)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> boost::math::constants::one_div_root_two_pi&lt;double&gt;()*exp(-0.5*x*x);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Standard normal cumulative distribution function</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</div><div class="line">X Phi(<span class="keyword">const</span> X&amp; x)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> 0.5*erfc(-boost::math::constants::one_div_root_two&lt;double&gt;()*x);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">enum</span> CP { call, put };</div><div class="line"></div><div class="line"><span class="comment">// Assume zero annual dividend yield (q=0).</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Price,<span class="keyword">typename</span> Sigma,<span class="keyword">typename</span> Tau,<span class="keyword">typename</span> Rate&gt;</div><div class="line"><span class="keyword">auto</span> black_scholes_option_price(CP cp, <span class="keywordtype">double</span> K, <span class="keyword">const</span> Price&amp; S, <span class="keyword">const</span> Sigma&amp; sigma, <span class="keyword">const</span> Tau&amp; tau, <span class="keyword">const</span> Rate&amp; r)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> d1 = (log(S/K) + (r+sigma*sigma/2)*tau) / (sigma*sqrt(tau));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> d2 = (log(S/K) + (r-sigma*sigma/2)*tau) / (sigma*sqrt(tau));</div><div class="line">  <span class="keywordflow">if</span> (cp == call)</div><div class="line">    <span class="keywordflow">return</span> S*Phi(d1) - exp(-r*tau)*K*Phi(d2);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> exp(-r*tau)*K*Phi(-d2) - S*Phi(-d1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1math_1_1differentiation.html">boost::math::differentiation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> K = 100.0; <span class="comment">// Strike price.</span></div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,3&gt; S(105); <span class="comment">// Stock price.</span></div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,0,3&gt; sigma(5); <span class="comment">// Volatility.</span></div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,0,0,1&gt; tau(30.0/365); <span class="comment">// Time to expiration in years. (30 days).</span></div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,0,0,0,1&gt; r(1.25/100); <span class="comment">// Interest rate.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> call_price = black_scholes_option_price(call, K, S, sigma, tau, r);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> put_price  = black_scholes_option_price(put,  K, S, sigma, tau, r);</div><div class="line"></div><div class="line">  <span class="comment">// Compare automatically calculated greeks by autodiff with formulas for greeks.</span></div><div class="line">  <span class="comment">// https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>((log(S/K) + (r+sigma*sigma/2)*tau) / (sigma*sqrt(tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>((log(S/K) + (r-sigma*sigma/2)*tau) / (sigma*sqrt(tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_call_delta = +Phi(+d1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_put_delta  = -Phi(-d1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_vega = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(S*phi(d1)*sqrt(tau));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_call_theta = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-S*phi(d1)*sigma/(2*sqrt(tau))-r*K*exp(-r*tau)*Phi(+d2));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_put_theta  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-S*phi(d1)*sigma/(2*sqrt(tau))+r*K*exp(-r*tau)*Phi(-d2));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_call_rho = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(+K*tau*exp(-r*tau)*Phi(+d2));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_put_rho  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-K*tau*exp(-r*tau)*Phi(-d2));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_gamma = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(phi(d1)/(S*sigma*sqrt(tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_vanna = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-phi(d1)*d2/sigma);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_charm = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(phi(d1)*(d2*sigma*sqrt(tau)-2*r*tau)/(2*tau*sigma*sqrt(tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_vomma = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(S*phi(d1)*sqrt(tau)*d1*d2/sigma);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_veta = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-S*phi(d1)*sqrt(tau)*(r*d1/(sigma*sqrt(tau))-(1+d1*d2)/(2*tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_speed = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-phi(d1)*(d1/(sigma*sqrt(tau))+1)/(S*S*sigma*sqrt(tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_zomma = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(phi(d1)*(d1*d2-1)/(S*sigma*sigma*sqrt(tau)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_color =</div><div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(-phi(d1)/(2*S*tau*sigma*sqrt(tau))*(1+(2*r*tau-d2*sigma*sqrt(tau))*d1/(sigma*sqrt(tau))));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> formula_ultima = -formula_vega*<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>((d1*d2*(1-d1*d2)+d1*d1+d2*d2)/(sigma*sigma));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::setprecision(std::numeric_limits&lt;double&gt;::digits10)</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff black-scholes call price = &quot;</span> &lt;&lt; call_price.derivative(0,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff black-scholes put  price = &quot;</span> &lt;&lt; put_price.derivative(0,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;\n## First-order Greeks\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call delta = &quot;</span> &lt;&lt; call_price.derivative(1,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula call delta = &quot;</span> &lt;&lt; formula_call_delta &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call vega  = &quot;</span> &lt;&lt; call_price.derivative(0,1,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula call vega  = &quot;</span> &lt;&lt; formula_vega &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call theta = &quot;</span> &lt;&lt; -call_price.derivative(0,0,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> <span class="comment">// minus sign due to tau = T-time</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula call theta = &quot;</span> &lt;&lt; formula_call_theta &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call rho   = &quot;</span> &lt;&lt; call_price.derivative(0,0,0,1) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula call rho   = &quot;</span> &lt;&lt; formula_call_rho &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put delta = &quot;</span> &lt;&lt; put_price.derivative(1,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula put delta = &quot;</span> &lt;&lt; formula_put_delta &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put vega  = &quot;</span> &lt;&lt; put_price.derivative(0,1,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula put vega  = &quot;</span> &lt;&lt; formula_vega &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put theta = &quot;</span> &lt;&lt; -put_price.derivative(0,0,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula put theta = &quot;</span> &lt;&lt; formula_put_theta &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put rho   = &quot;</span> &lt;&lt; put_price.derivative(0,0,0,1) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; formula put rho   = &quot;</span> &lt;&lt; formula_put_rho &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;\n## Second-order Greeks\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call gamma = &quot;</span> &lt;&lt; call_price.derivative(2,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  gamma = &quot;</span> &lt;&lt; put_price.derivative(2,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula gamma = &quot;</span> &lt;&lt; formula_gamma &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call vanna = &quot;</span> &lt;&lt; call_price.derivative(1,1,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  vanna = &quot;</span> &lt;&lt; put_price.derivative(1,1,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula vanna = &quot;</span> &lt;&lt; formula_vanna &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call charm = &quot;</span> &lt;&lt; -call_price.derivative(1,0,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  charm = &quot;</span> &lt;&lt; -put_price.derivative(1,0,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula charm = &quot;</span> &lt;&lt; formula_charm &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call vomma = &quot;</span> &lt;&lt; call_price.derivative(0,2,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  vomma = &quot;</span> &lt;&lt; put_price.derivative(0,2,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula vomma = &quot;</span> &lt;&lt; formula_vomma &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call veta = &quot;</span> &lt;&lt; call_price.derivative(0,1,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  veta = &quot;</span> &lt;&lt; put_price.derivative(0,1,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula veta = &quot;</span> &lt;&lt; formula_veta &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;\n## Third-order Greeks\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call speed = &quot;</span> &lt;&lt; call_price.derivative(3,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  speed = &quot;</span> &lt;&lt; put_price.derivative(3,0,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula speed = &quot;</span> &lt;&lt; formula_speed &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call zomma = &quot;</span> &lt;&lt; call_price.derivative(2,1,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  zomma = &quot;</span> &lt;&lt; put_price.derivative(2,1,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula zomma = &quot;</span> &lt;&lt; formula_zomma &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call color = &quot;</span> &lt;&lt; call_price.derivative(2,0,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  color = &quot;</span> &lt;&lt; put_price.derivative(2,0,1,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula color = &quot;</span> &lt;&lt; formula_color &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff call ultima = &quot;</span> &lt;&lt; call_price.derivative(0,3,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;autodiff put  ultima = &quot;</span> &lt;&lt; put_price.derivative(0,3,0,0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;      formula ultima = &quot;</span> &lt;&lt; formula_ultima &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    ;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Compile:</span></div><div class="line"><span class="comment">$ g++ -std=c++1z example/black_scholes.cpp</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Output:</span></div><div class="line"><span class="comment">$ ./a.out</span></div><div class="line"><span class="comment">autodiff black-scholes call price = 56.5136030677739</span></div><div class="line"><span class="comment">autodiff black-scholes put  price = 51.4109161009333</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">## First-order Greeks</span></div><div class="line"><span class="comment">autodiff call delta = 0.773818444921273</span></div><div class="line"><span class="comment"> formula call delta = 0.773818444921274</span></div><div class="line"><span class="comment">autodiff call vega  = 9.05493427705736</span></div><div class="line"><span class="comment"> formula call vega  = 9.05493427705736</span></div><div class="line"><span class="comment">autodiff call theta = -275.73013426444</span></div><div class="line"><span class="comment"> formula call theta = -275.73013426444</span></div><div class="line"><span class="comment">autodiff call rho   = 2.03320550539396</span></div><div class="line"><span class="comment"> formula call rho   = 2.03320550539396</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">autodiff put delta = -0.226181555078726</span></div><div class="line"><span class="comment"> formula put delta = -0.226181555078726</span></div><div class="line"><span class="comment">autodiff put vega  = 9.05493427705736</span></div><div class="line"><span class="comment"> formula put vega  = 9.05493427705736</span></div><div class="line"><span class="comment">autodiff put theta = -274.481417851526</span></div><div class="line"><span class="comment"> formula put theta = -274.481417851526</span></div><div class="line"><span class="comment">autodiff put rho   = -6.17753255212599</span></div><div class="line"><span class="comment"> formula put rho   = -6.17753255212599</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">## Second-order Greeks</span></div><div class="line"><span class="comment">autodiff call gamma = 0.00199851912993254</span></div><div class="line"><span class="comment">autodiff put  gamma = 0.00199851912993254</span></div><div class="line"><span class="comment">      formula gamma = 0.00199851912993254</span></div><div class="line"><span class="comment">autodiff call vanna = 0.0410279463126531</span></div><div class="line"><span class="comment">autodiff put  vanna = 0.0410279463126531</span></div><div class="line"><span class="comment">      formula vanna = 0.0410279463126531</span></div><div class="line"><span class="comment">autodiff call charm = -1.2505564233679</span></div><div class="line"><span class="comment">autodiff put  charm = -1.2505564233679</span></div><div class="line"><span class="comment">      formula charm = -1.2505564233679</span></div><div class="line"><span class="comment">autodiff call vomma = -0.928114149313108</span></div><div class="line"><span class="comment">autodiff put  vomma = -0.928114149313108</span></div><div class="line"><span class="comment">      formula vomma = -0.928114149313107</span></div><div class="line"><span class="comment">autodiff call veta = 26.7947073115641</span></div><div class="line"><span class="comment">autodiff put  veta = 26.7947073115641</span></div><div class="line"><span class="comment">      formula veta = 26.7947073115641</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">## Third-order Greeks</span></div><div class="line"><span class="comment">autodiff call speed = -2.90117322380992e-05</span></div><div class="line"><span class="comment">autodiff put  speed = -2.90117322380992e-05</span></div><div class="line"><span class="comment">      formula speed = -2.90117322380992e-05</span></div><div class="line"><span class="comment">autodiff call zomma = -0.000604548369901419</span></div><div class="line"><span class="comment">autodiff put  zomma = -0.000604548369901419</span></div><div class="line"><span class="comment">      formula zomma = -0.000604548369901419</span></div><div class="line"><span class="comment">autodiff call color = -0.0184014426606065</span></div><div class="line"><span class="comment">autodiff put  color = -0.0184014426606065</span></div><div class="line"><span class="comment">      formula color = -0.0184014426606065</span></div><div class="line"><span class="comment">autodiff call ultima = -0.0922426864775683</span></div><div class="line"><span class="comment">autodiff put  ultima = -0.0922426864775683</span></div><div class="line"><span class="comment">      formula ultima = -0.0922426864775685</span></div><div class="line"><span class="comment">**/</span></div></div><!-- fragment --></p>
<hr/>
<h2><a class="anchor" id="example-multi-variable"></a>
Example 4: Multi-variable mixed partial derivatives</h2>
<h3>Calculate mixed partial derivatives of \(f(w,x,y,z)=\exp\left(w\sin\left(\frac{x\log(y)}{z}\right)+\sqrt{\frac{wz}{xy}}\right)+\frac{w^2}{\tan(z)}\) at \((w,x,y,z)=(11,12,13,14)\).</h3>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/math/differentiation/autodiff.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W,<span class="keyword">typename</span> X,<span class="keyword">typename</span> Y,<span class="keyword">typename</span> Z&gt;</div><div class="line"><span class="keyword">auto</span> f(<span class="keyword">const</span> W&amp; w, <span class="keyword">const</span> X&amp; x, <span class="keyword">const</span> Y&amp; y, <span class="keyword">const</span> Z&amp; z)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line">  <span class="keywordflow">return</span> exp(w*sin(x*log(y)/z) + sqrt(w*z/(x*y))) + w*w/tan(z);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Derivatives calculated from symbolic differentiation by Mathematica for comparison.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> answers[] = { 19878.406289804349223, 20731.748382749395173, 14667.607676239390148, 1840.5599364498131187,</div><div class="line">  -9219.3180052370721296, -7272.3006340128117838, -2135.2963700622839242, 3095.0810272518467995, 4249.0267629086156274,</div><div class="line">  2063.9890610627344166, -885.52841148764960841, -1962.1334204417431580, -1846.8998307870845186, -160.95901276032957552,</div><div class="line">  1091.0394123416339941, 452.43955743452299467, 666.40139227277049900, -415.64641143336291078, -625.14641790399863613,</div><div class="line">  369.94916697726171101, -24330.896138493893431, -18810.416051756267521, -4890.4061227023590999, 8833.0050547689764171,</div><div class="line">  8484.3507396816137478, 3097.2041512403988935, -3255.0451367834406121, -4342.7785533321930979, -2407.9872379065234860,</div><div class="line">  861.11739164703000843, 2436.7437257633086191, -19.246496107338277838, 187.78551488705117144, -1259.4660633352121952,</div><div class="line">  -709.68605239721582613, 1423.0005586086045369, 484.92081333892339591, 763.97468850744531805, -327.41629182280555682,</div><div class="line">  -1122.3377072484945211, 23973.060071923469893, 8840.5431517787968699, -9082.5710332215493783, -12270.273782892587177,</div><div class="line">  -4320.4340714205998547, 3281.3519677072808985, 5880.3362630834187672, -1288.4827852197065498, -803.97135376265805266,</div><div class="line">  -2986.3872453316983903, -586.73168598226583063, 3929.0731892807393562, 1453.7282809838266301, 1037.8780716859538297,</div><div class="line">  -1482.7458052774013366, -1877.1347929338288106, -931.71387103692982071, 254.65655904203226329, 1391.2480647456116638,</div><div class="line">  -431.48205631541379551, 16975.340053651795550, 19662.603563033417098, 15765.851307040200043, 3972.1550361959370138,</div><div class="line">  -8681.7485397897205125, -7703.1830424603876567, -3049.7086965695187740, 2971.4696859922708762, 4370.1964998575500257,</div><div class="line">  2524.6324733574356708, -656.60800002366790717, -2423.4529173252581326, -2074.9876642042632042, -381.22537949881329845,</div><div class="line">  1219.5072457919973510, 805.38022398408368773, 838.40041900589123805, -390.61251971089838316, -828.20854892982357583,</div><div class="line">  293.89998544549947901, -22965.859858439519778, -20026.691015299296217, -7316.0927450633559965, 8632.4661339726146593,</div><div class="line">  8987.0468828704522662, 4199.9253995361375411, -2958.4298508960628932, -5665.5638912186240622, -2945.4045522503416159,</div><div class="line">  555.65662724782625247, 2936.7964035500791392, 651.51916507471100081, 444.76294274861551486, -1390.9896717990958013,</div><div class="line">  -1142.8614689467638609, 1541.9787231173408435, 455.71460632938144702, 998.79435039403570373, -204.84855819811212954,</div><div class="line">  -1560.3541154604787861, 25278.294506052472235, 11873.223371790464699, -8242.1873033688781033, -15939.980564174657519,</div><div class="line">  -5648.8335396980314868, 2751.5139261227171185, 7349.4320024790771292, 194.99725459803711274, -402.81568576826882656,</div><div class="line">  -3518.8719086830633712, -1494.3047934746826191, 4640.9275094260800875, 1585.7577052032271420, 1565.1699924044071379,</div><div class="line">  -1513.2598097335400189, -2974.4378726746800928, -1203.2362926538234416, 72.524259498791533840, 1871.6252742534199495,</div><div class="line">  -2.4899843373796816664, 14462.744235186331026, 18367.747409164327117, 16565.763244996739614, 6054.3152526511029520,</div><div class="line">  -8084.9812719820301461, -7988.3143591282012972, -3989.3193469414926985, 2616.7211865346490167, 4420.8592709704865621,</div><div class="line">  2973.0335197645479091, -324.14530169827137080, -2843.2420399589692219, -2281.4618061432895177, -642.93532295820559249,</div><div class="line">  1299.2872741769553585, 1238.5970833720697622, 1021.3340427708481651, -329.05293450692710796, -1046.2543015440520751,</div><div class="line">  134.73430395544806552, -21431.416435076611924, -20856.882814790157847, -9829.2619705919309076, 7806.8586470778118280,</div><div class="line">  9319.7000856495681801, 5319.8987680257582564, -2387.9548264668417364, -6958.2985251653597607, -3468.5391063919725607,</div><div class="line">  130.41672533427094017, 3371.1399302351759874, 1569.2326780049081053, 750.09121011790652458, -1462.2572096265974522,</div><div class="line">  -1661.5778096302406157, 1509.6285286038691333, 383.89509025808162595, 1248.0510963436380133, 17.185695642652602749,</div><div class="line">  -2038.0245980026048531, 26118.981320178235148, 14943.619434822279033, -6650.6862622761310724, -19519.815295474040679,</div><div class="line">  -6983.1902365008486475, 1899.2975028736889830, 8715.0036526429634882, 2368.1506906818643019, 136.89207930934828319,</div><div class="line">  -3954.7327061634171420, -2673.5564402311867864, 5078.4839352490435947, 1643.4591437212048172, 2182.2169795063802937,</div><div class="line">  -1345.8388309636205015, -4309.2853506291084135, -1488.0508699224178177, -228.05849430703437209, 2373.3989404257091779,</div><div class="line">  773.84813281039280582, 12294.403877378555486, 16977.349665718583019, 17057.174756225031750, 8121.1897585118309359,</div><div class="line">  -7458.4435414062843899, -8134.1311608827380587, -4912.8811586137844196, 2030.6531360989337179, 4407.4905277094127309,</div><div class="line">  3392.4345688258927524, 104.03723558415061987, -3180.8176204844632144, -2460.5239870750694373, -938.22093140691334328,</div><div class="line">  1315.2469055718764567, 1735.8623924059921882, 1209.7596572231669549, -227.33200545666422971, -1266.1262099919292594,</div><div class="line">  -123.07945723381491568, -19806.907943338346855, -21314.816354405752293, -12317.583844301308050, 6349.4186598882814744,</div><div class="line">  9489.8196876965277351, 6409.5389484563099944, -1550.2817990131252676, -8109.7111997852175121, -3957.8403302968748777,</div><div class="line">  -404.07965558366678588, 3693.6143513011819801, 2716.1466583227900648, 1094.5910866413989005, -1456.2696455499464209,</div><div class="line">  -2244.3806087356369623, 1268.5938915562618711, 265.22067303277493466, 1496.0915787786394884, 354.61373510477227819,</div><div class="line">  -2508.4771100486841292, 26517.861408751573247, 17922.983877419151441, -4328.2591421276680409, -22704.702459400809491,</div><div class="line">  -8268.6137471737389714, 740.40560743926114647, 9848.9001828360350810, 5213.5983414762103377, 801.24629237235082333,</div><div class="line">  -4241.8701339207678459, -4092.2413558685505706, 5074.4359092060839438, 1607.7653292548209160, 2861.1556511165675262,</div><div class="line">  -918.93105463172960902, -5803.2113236460920193, -1767.5418979944773144, -663.06462075200757263, 2837.9031946139384145,</div><div class="line">  1976.3196007477977178 };</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1math_1_1differentiation.html">boost::math::differentiation</a>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">int</span> Nw=3; <span class="comment">// Max order of derivative to calculate for w</span></div><div class="line">  constexpr <span class="keywordtype">int</span> Nx=2; <span class="comment">// Max order of derivative to calculate for x</span></div><div class="line">  constexpr <span class="keywordtype">int</span> Ny=4; <span class="comment">// Max order of derivative to calculate for y</span></div><div class="line">  constexpr <span class="keywordtype">int</span> Nz=3; <span class="comment">// Max order of derivative to calculate for z</span></div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,Nw&gt; w(11);</div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,0,Nx&gt; x(12);</div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,0,0,Ny&gt; y(13);</div><div class="line">  <span class="keyword">const</span> autodiff::variable&lt;double,0,0,0,Nz&gt; z(14);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v = f(w,x,y,z); <span class="comment">// auto = autodiff::variable&lt;double,Nw,Nx,Ny,Nz&gt;</span></div><div class="line">  <span class="keywordtype">int</span> ia=0;</div><div class="line">  <span class="keywordtype">double</span> max_relative_error=0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iw=0 ; iw&lt;=Nw ; ++iw)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ix=0 ; ix&lt;=Nx ; ++ix)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iy=0 ; iy&lt;=Ny ; ++iy)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iz=0 ; iz&lt;=Nz ; ++iz)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> value = v.derivative(iw,ix,iy,iz);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> error = std::fabs(value/answers[ia++] - 1);</div><div class="line">          max_relative_error = std::max(error, max_relative_error);</div><div class="line">        }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;max_relative_error = &quot;</span> &lt;&lt; std::setprecision(3) &lt;&lt; max_relative_error</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; out of &quot;</span> &lt;&lt; ia &lt;&lt; <span class="stringliteral">&quot; calculated values.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Compile:</span></div><div class="line"><span class="comment">$ g++ -std=c++1z example/mixed_partials.cpp</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Output:</span></div><div class="line"><span class="comment">$ ./a.out</span></div><div class="line"><span class="comment">max_relative_error = 6.82e-13 out of 240 calculated values.</span></div><div class="line"><span class="comment">**/</span></div></div><!-- fragment --></p>
<p>The above calculates </p><p class="formulaDsp">
\[ {\tt v.derivative(iw,ix,iy,iz)} = \frac{\partial^{i_w+i_x+i_y+i_z}f}{\partial w^{i_w}\partial x^{i_x}\partial y^{i_y}\partial z^{i_z}}(11,12,13,14) \qquad\text{for each}\qquad (i_w,i_x,i_y,i_z)\in \mathbb{N}_4\times\mathbb{N}_3\times\mathbb{N}_5\times\mathbb{N}_4 \]
</p>
<p>where \(\mathbb{N}_i=\{0,1,2,...,i-1\}\). For testing purposes, the \(4\times3\times5\times4=240\)-element <code>answers[]</code> array was calculated independently by Mathematica (example/mixed_partials.nb) in 2 steps:</p>
<ol type="1">
<li><a href="https://reference.wolfram.com/language/tutorial/SymbolicComputation.html">Symbolic differentiation</a></li>
<li><a href="https://reference.wolfram.com/language/tutorial/ArbitraryPrecisionNumbers.html">Arbitrary-precision computation</a> to calculate the answers to 20 decimal places.</li>
</ol>
<p>Out of the 240 calculated values, the maximum relative error between the values calculated by Mathematica vs. the Boost Autodiff library is found to be about \(6.82\times10^{-13}\) using the standard IEEE double precision floating point data type. Since the data type is a template variable, the error can be reduced arbitrarily by using a data type with greater precision.</p>
<hr/>
<h1><a class="anchor" id="mathematics"></a>
Mathematics</h1>
<p>In order for the usage of the autodiff library to make sense, a basic understanding of the mathematics will help.</p>
<h2><a class="anchor" id="taylor-series"></a>
Truncated Taylor Series</h2>
<p>Basic calculus courses teach that a real <a href="https://en.wikipedia.org/wiki/Analytic_function">analytic function</a> \(f : D\rightarrow\mathbb{R}\) is one which can be expressed as a Taylor series at a point \(x_0\in D\subseteq\mathbb{R}\):</p>
<p class="formulaDsp">
\[ f(x) = f(x_0) + f&#39;(x_0)(x-x_0) + \frac{f&#39;&#39;(x_0)}{2!}(x-x_0)^2 + \frac{f&#39;&#39;&#39;(x_0)}{3!}(x-x_0)^3 + \cdots \]
</p>
<p>One way of thinking about this form is that given the value of an analytic function \(f(x_0)\) and its derivatives \(f&#39;(x_0), f&#39;&#39;(x_0), f&#39;&#39;&#39;(x_0), ...\) evaluated at a point \(x_0\), then the value of the function \(f(x)\) can be obtained at any other point \(x\in D\) using the above formula.</p>
<p>Let us make the substitution \(x=x_0+\varepsilon\) and rewrite the above equation to get:</p>
<p class="formulaDsp">
\[ f(x_0+\varepsilon) = f(x_0) + f&#39;(x_0)\varepsilon + \frac{f&#39;&#39;(x_0)}{2!}\varepsilon^2 + \frac{f&#39;&#39;&#39;(x_0)}{3!}\varepsilon^3 + \cdots \]
</p>
<p>Now consider \(\varepsilon\) as <b>an abstract algebraic entity that never acquires a numeric value</b>, much like one does in basic algebra with variables like \(x\) or \(y\). For example, we can still manipulate entities like \(xy\) and \((1+2x+3x^2)\) without having to assign specific numbers to them.</p>
<p>Using this formula, autodiff goes in the other direction. Given a general formula/algorithm for calculating \(f(x_0+\varepsilon)\), the derivatives are obtained from the coefficients of the powers of \(\varepsilon\) in the resulting computation. The general coefficient for \(\varepsilon^n\) is</p>
<p class="formulaDsp">
\[\frac{f^{(n)}(x_0)}{n!}.\]
</p>
<p>Thus to obtain \(f^{(n)}(x_0)\), the coefficient of \(\varepsilon^n\) is multiplied by \(n!\).</p>
<h3><a class="anchor" id="taylor-series-example"></a>
Example</h3>
<p>Apply the above technique to calculate the derivatives of \(f(x)=x^4\) at \(x_0=2\).</p>
<p>The first step is to evaluate \(f(x_0+\varepsilon)\) and simply go through the calculation/algorithm, treating \(\varepsilon\) as an abstract algebraic entity:</p>
<p class="formulaDsp">
\begin{align*} f(x_0+\varepsilon) &amp;= f(2+\varepsilon) \\ &amp;= (2+\varepsilon)^4 \\ &amp;= \left(4+4\varepsilon+\varepsilon^2\right)^2 \\ &amp;= 16+32\varepsilon+24\varepsilon^2+8\varepsilon^3+\varepsilon^4. \end{align*}
</p>
<p>Equating the powers of \(\varepsilon\) from this result with the above \(\varepsilon\)-taylor expansion yields the following equalities: </p><p class="formulaDsp">
\[ f(2) = 16, \qquad f&#39;(2) = 32, \qquad \frac{f&#39;&#39;(2)}{2!} = 24, \qquad \frac{f&#39;&#39;&#39;(2)}{3!} = 8, \qquad \frac{f^{(4)}(2)}{4!} = 1, \qquad \frac{f^{(5)}(2)}{5!} = 0. \]
</p>
<p>Multiplying both sides by the respective factorials gives </p><p class="formulaDsp">
\[ f(2) = 16, \qquad f&#39;(2) = 32, \qquad f&#39;&#39;(2) = 48, \qquad f&#39;&#39;&#39;(2) = 48, \qquad f^{(4)}(2) = 24, \qquad f^{(5)}(2) = 0. \]
</p>
<p>These values can be directly confirmed by the <a href="https://en.wikipedia.org/wiki/Power_rule">power rule</a> applied to \(f(x)=x^4\).</p>
<hr/>
<h2><a class="anchor" id="arithmetic"></a>
Arithmetic</h2>
<p>What was essentially done above was to take a formula/algorithm for calculating \(f(x_0)\) from a number \(x_0\), and instead apply the same formula/algorithm to a polynomial \(x_0+\varepsilon\). Intermediate steps operate on values of the form</p>
<p class="formulaDsp">
\[ {\bf x} = x_0 + x_1\varepsilon + x_2\varepsilon^2 +\cdots+ x_N\varepsilon^N \]
</p>
<p>and the final return value is of this polynomial form as well. In other words, the normal arithmetic operators \(+,-,\times,\div\) applied to numbers \(x\) are instead applied to polynomials \(\bf x\). Through the overloading of C++ operators and functions, floating point data types are replaced with data types that represent these polynomials. More specifically, C++ types such as <code>double</code> are replaced with <code>std::array&lt;double,N+1&gt;</code>, which hold the above \(N+1\) coefficients \(x_i\), and are wrapped in a <code>class</code> that overloads all of the arithmetic operators.</p>
<p>The logic of these arithmetic operators simply mirror that which is applied to polynomials. We'll look at each of the 4 arithmetic operators in detail.</p>
<h3><a class="anchor" id="arithmetic-addition"></a>
Addition</h3>
<p>Given polynomials \(\bf x\) and \(\bf y\), how is \(\bf z=x+y\) calculated?</p>
<p>To answer this, one simply expands \(\bf x\) and \(\bf y\) into their polynomial forms and add them together:</p>
<p class="formulaDsp">
\begin{align*} {\bf z} &amp;= {\bf x} + {\bf y} \\ &amp;= \left(\sum_{i=0}^Nx_i\varepsilon^i\right) + \left(\sum_{i=0}^Ny_i\varepsilon^i\right) \\ &amp;= \sum_{i=0}^N(x_i+y_i)\varepsilon^i \\ z_i &amp;= x_i + y_i \qquad \text{for}\; i\in\{0,1,2,...,N\}. \end{align*}
</p>
<h3><a class="anchor" id="arithmetic-subtraction"></a>
Subtraction</h3>
<p>Subtraction follows the same form as addition:</p>
<p class="formulaDsp">
\begin{align*} {\bf z} &amp;= {\bf x} - {\bf y} \\ &amp;= \left(\sum_{i=0}^Nx_i\varepsilon^i\right) - \left(\sum_{i=0}^Ny_i\varepsilon^i\right) \\ &amp;= \sum_{i=0}^N(x_i-y_i)\varepsilon^i \\ z_i &amp;= x_i - y_i \qquad \text{for}\; i\in\{0,1,2,...,N\}. \end{align*}
</p>
<h3><a class="anchor" id="arithmetic-multiplication"></a>
Multiplication</h3>
<p>Multiplication is a bit more interesting:</p>
<p class="formulaDsp">
\begin{align*} {\bf z} &amp;= {\bf x} \times {\bf y} \\ &amp;= \left(\sum_{i=0}^Nx_i\varepsilon^i\right) \left(\sum_{i=0}^Ny_i\varepsilon^i\right) \\ &amp;= x_0y_0 + (x_0y_1+x_1y_0)\varepsilon + (x_0y_2+x_1y_1+x_2y_0)\varepsilon^2 + \cdots + \left(\sum_{j=0}^Nx_jy_{N-j}\right)\varepsilon^N + O\left(\varepsilon^{N+1}\right) \\ &amp;= \sum_{i=0}^N\sum_{j=0}^ix_jy_{i-j}\varepsilon^i + O\left(\varepsilon^{N+1}\right) \\ z_i &amp;= \sum_{j=0}^ix_jy_{i-j} \qquad \text{for}\; i\in\{0,1,2,...,N\}. \end{align*}
</p>
<p>In the case of multiplication, terms involving powers of \(\varepsilon\) greater than \(N\), collectively denoted by \(O\left(\varepsilon^{N+1}\right)\), are simply discarded. Fortunately, the values of \(z_i\) for \(i\le N\) do not depend on any of these discarded terms, so there is no loss of precision in the final answer. The only information that is lost are the values of higher order derivatives, which we are not interested in anyway. If we were, then we would have simply chosen a larger value of \(N\) to begin with.</p>
<h3><a class="anchor" id="arithmetic-division"></a>
Division</h3>
<p>Division is not directly calculated as are the others. Instead, to find the components of \({\bf z}={\bf x}\div{\bf y}\) we require that \({\bf x}={\bf y}\times{\bf z}\). This yields a recursive formula for the components \(z_i\):</p>
<p class="formulaDsp">
\begin{align*} x_i &amp;= \sum_{j=0}^iy_jz_{i-j} \\ &amp;= y_0z_i + \sum_{j=1}^iy_jz_{i-j} \\ z_i &amp;= \frac{1}{y_0}\left(x_i - \sum_{j=1}^iy_jz_{i-j}\right) \qquad \text{for}\; i\in\{0,1,2,...,N\}. \end{align*}
</p>
<p>In the case of division, the values for \(z_i\) must be calculated sequentially, since \(z_i\) depends on the previously calculated values \(z_0, z_1, ..., z_{i-1}\).</p>
<hr/>
<h2><a class="anchor" id="general-functions"></a>
General Functions</h2>
<p>When calling standard mathematical functions such as <code>log()</code>, <code>cos()</code>, etc. how should these be written in order to support autodiff variable types? That is, how should they be written to provide accurate derivatives?</p>
<p>To simplify notation, for a given polynomial \({\bf x} = x_0 + x_1\varepsilon + x_2\varepsilon^2 +\cdots+ x_N\varepsilon^N\) define</p>
<p class="formulaDsp">
\[ {\bf x}_\varepsilon = x_1\varepsilon + x_2\varepsilon^2 +\cdots+ x_N\varepsilon^N = \sum_{i=1}^Nx_i\varepsilon^i \]
</p>
<p>This allows for a concise expression of a general function \(f\) of \(\bf x\):</p>
<p class="formulaDsp">
\begin{align*} f({\bf x}) &amp;= f(x_0 + {\bf x}_\varepsilon) \\ &amp; = f(x_0) + f&#39;(x_0){\bf x}_\varepsilon + \frac{f&#39;&#39;(x_0)}{2!}{\bf x}_\varepsilon^2 + \frac{f&#39;&#39;&#39;(x_0)}{3!}{\bf x}_\varepsilon^3 + \cdots + \frac{f^{(N)}(x_0)}{N!}{\bf x}_\varepsilon^N + O\left(\varepsilon^{N+1}\right) \\ &amp; = \sum_{i=0}^N\frac{f^{(i)}(x_0)}{i!}{\bf x}_\varepsilon^i + O\left(\varepsilon^{N+1}\right) \end{align*}
</p>
<p>where \(\varepsilon\) has been substituted with \({\bf x}_\varepsilon\) in the \(\varepsilon\)-taylor series for \(f(x)\). This form gives a recipe for calculating \(f({\bf x})\) in general from regular numeric calculations \(f(x_0)\), \(f&#39;(x_0)\), \(f&#39;&#39;(x_0)\), ... and successive powers of the epsilon terms \({\bf x}_\varepsilon\).</p>
<p>For an application in which we are interested in up to \(N\) derivatives in \(x\) the data structure to hold this information is an \((N+1)\)-element array <code>v</code> whose general element is</p>
<p class="formulaDsp">
\[ {\tt v[i]} = \frac{f^{(i)}(x_0)}{i!} \qquad \text{for}\; i\in\{0,1,2,...,N\}. \]
</p>
<hr/>
<h2><a class="anchor" id="multiple-variables"></a>
Multiple Variables</h2>
<p>In C++, the generalization to mixed partial derivatives with multiple independent variables is conveniently achieved with recursion. To begin to see the recursive pattern, consider a two-variable function \(f(x,y)\). Since \(x\) and \(y\) are independent, they require their own independent epsilons \(\varepsilon_x\) and \(\varepsilon_y\), respectively.</p>
<p>Expand \(f(x,y)\) for \(x=x_0+\varepsilon_x\): </p><p class="formulaDsp">
\begin{align*} f(x_0+\varepsilon_x,y) &amp;= f(x_0,y) + \frac{\partial f}{\partial x}(x_0,y)\varepsilon_x + \frac{1}{2!}\frac{\partial^2 f}{\partial x^2}(x_0,y)\varepsilon_x^2 + \frac{1}{3!}\frac{\partial^3 f}{\partial x^3}(x_0,y)\varepsilon_x^3 + \cdots + \frac{1}{M!}\frac{\partial^M f}{\partial x^M}(x_0,y)\varepsilon_x^M + O\left(\varepsilon_x^{M+1}\right) \\ &amp;= \sum_{i=0}^M\frac{1}{i!}\frac{\partial^i f}{\partial x^i}(x_0,y)\varepsilon_x^i + O\left(\varepsilon_x^{M+1}\right). \end{align*}
</p>
<p>Next, expand \(f(x_0+\varepsilon_x,y)\) for \(y=y_0+\varepsilon_y\): </p><p class="formulaDsp">
\begin{align*} f(x_0+\varepsilon_x,y_0+\varepsilon_y) &amp;= \sum_{j=0}^N\frac{1}{j!}\frac{\partial^j}{\partial y^j} \left(\sum_{i=0}^M\frac{1}{i!}\frac{\partial^if}{\partial x^i}\right)(x_0,y_0)\varepsilon_x^i\varepsilon_y^j + O\left(\varepsilon_x^{M+1}\right) + O\left(\varepsilon_y^{N+1}\right) \\ &amp;= \sum_{i=0}^M\sum_{j=0}^N\frac{1}{i!j!}\frac{\partial^{i+j}f}{\partial x^i\partial y^j}(x_0,y_0) \varepsilon_x^i\varepsilon_y^j + O\left(\varepsilon_x^{M+1}\right) + O\left(\varepsilon_y^{N+1}\right). \end{align*}
</p>
<p>Similarly to the single-variable case, for an application in which we are interested in up to \(M\) derivatives in \(x\) and \(N\) derivatives in \(y\), the data structure to hold this information is an \((M+1)\times(N+1)\) array <code>v</code> whose element at \((i,j)\) is</p>
<p class="formulaDsp">
\[ {\tt v[i][j]} = \frac{1}{i!j!}\frac{\partial^{i+j}f}{\partial x^i\partial y^j}(x_0,y_0) \qquad \text{for}\; (i,j)\in\{0,1,2,...,M\}\times\{0,1,2,...,N\}. \]
</p>
<p>The generalization to additional independent variables follows the same pattern. This is made more concrete with C++ code in the next section.</p>
<hr/>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<h2><a class="anchor" id="usage-single-variable"></a>
Single Variable</h2>
<p>To calculate derivatives of a single variable \(x\), at a particular value \(x_0\), the following must be specified at compile-time:</p>
<ol type="1">
<li>The numeric data type <code>T</code> of \(x_0\). Examples: <code>double</code>, <code>boost::multiprecision::cpp_dec_float_100</code>, etc.</li>
<li>The <b>maximum</b> derivative order \(M\) that is to be calculated with respect to \(x\).</li>
</ol>
<p>Note that both of these requirements are entirely analogous to declaring and using a <code>std::array&lt;T,N&gt;</code>. <code>T</code> and <code>N</code> must be set as compile-time, but which elements in the array are accessed can be determined at run-time, just as the choice of what derivatives to query in autodiff can be made during run-time.</p>
<p>To declare and initialize \(x\):</p>
<div class="fragment"><div class="line">boost::math::differentiation::autodiff::variable&lt;T,M&gt; x(x0);</div></div><!-- fragment --><p>where <code>x0</code> is a run-time value of type <code>T</code>. Assuming <code>0 &lt; M</code>, this represents the polynomial \( x_0 + \varepsilon \). Internally, the member variable of type <code>std::array&lt;T,M&gt;</code> is <code>v = { x0, 1, 0, 0, ... }</code>, consistent with the above mathematical treatise.</p>
<p>To find the derivatives \(f^{(n)}(x_0)\) for \(0\le n\le M\) of a function \(f : \mathbb{R}\rightarrow\mathbb{R}\), the function can be represented as a template</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T f(T x);</div></div><!-- fragment --><p>Using a generic type <code>T</code> allows for <code>x</code> to be of a regular type such as <code>double</code>, but also allows for <code>boost::math::differentiation::autodiff::variable&lt;&gt;</code> types.</p>
<p>Internal calls to mathematical functions must allow for <a href="https://en.wikipedia.org/wiki/Argument-dependent_name_lookup">argument-dependent lookup</a> (ADP). Many standard library functions are overloaded in the <code>boost::math::differentiation::autodiff</code> namespace. For example, instead of calling <code>std::cos(x)</code> from within <code>f</code>, include the line <code>using std::cos;</code> and call <code>cos(x)</code> without a namespace prefix.</p>
<p>Calling \(f\) and retrieving the calculated value and derivatives:</p>
<div class="fragment"><div class="line">boost::math::differentiation::autodiff::variable&lt;T,M&gt; x(x0);</div><div class="line">boost::math::differentiation::autodiff::variable&lt;T,M&gt; y = f(x);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0 ; n&lt;=M ; ++n)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;y.derivative(&quot;</span>&lt;&lt;n&lt;&lt;<span class="stringliteral">&quot;) == &quot;</span> &lt;&lt; y.derivative(n) &lt;&lt; std::endl;</div></div><!-- fragment --><p><code>y.derivative(0)</code> returns the undifferentiated value \(f(x_0)\), and <code>y.derivative(n)</code> returns \(f^{(n)}(x_0)\). Casting <code>y</code> to type <code>T</code> also gives the undifferentiated value. In other words, the following 3 values are equal:</p><ol type="1">
<li><code>f(x0)</code></li>
<li><code>y.derivative(0)</code></li>
<li><code>static_cast&lt;T&gt;(y)</code></li>
</ol>
<h2><a class="anchor" id="usage-multiple-variables"></a>
Multiple Variables</h2>
<p>Independent variables are represented in autodiff as independent dimensions within a multi-dimensional array. This is perhaps best illustrated with examples.</p>
<p>The following instantiates a variable of \(x=13\) with up to 3 orders of derivatives: </p><div class="fragment"><div class="line">boost::math::differentiation::autodiff::variable&lt;double,3&gt; x(13);</div></div><!-- fragment --><p>This instantiates <em>an independent</em> value of \(y=14\) with up to 4 orders of derivatives: </p><div class="fragment"><div class="line">boost::math::differentiation::autodiff::variable&lt;double,0,4&gt; y(14);</div></div><!-- fragment --><p>Combining them together <em>promotes</em> their data type automatically to the smallest multidimensional array that accommodates both. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> z = 10*x*x + 50*x*y + 100*y*y; <span class="comment">// z is promoted to boost::math::differentiation::autodiff::variable&lt;double,3,4&gt;</span></div></div><!-- fragment --><p>The object <code>z</code> holds a 2-dimensional array, thus <code>derivative(...)</code> is a 2-parameter method:</p>
<p class="formulaDsp">
\[ {\tt z.derivative(i,j)} = \frac{\partial^{i+j}f}{\partial x^i\partial y^j}(13,14) \qquad \text{for}\; (i,j)\in\{0,1,2,3\}\times\{0,1,2,3,4\}. \]
</p>
<p>A few values of the result can be confirmed through inspection: </p><div class="fragment"><div class="line">z.derivative(2,0) == 20</div><div class="line">z.derivative(1,1) == 50</div><div class="line">z.derivative(0,2) == 200</div></div><!-- fragment --><p>Note how the position of the parameters in <code>derivative(..)</code> match how <code>x</code> and <code>y</code> were declared. This will be clarified next.</p>
<h3><a class="anchor" id="two-rules"></a>
Two Rules of Variable Initialization</h3>
<p>In general, there are two rules to keep in mind when dealing with multiple variables:</p>
<ol type="1">
<li>Independent variables correspond to parameter position, in both the declaration <code>boost::math::differentiation::autodiff::variable&lt;T,...&gt;</code> and calls to <code>derivative(...)</code>.</li>
<li>The last template position in a value-initialized instance determines which variable a derivative will be taken with respect to.</li>
</ol>
<p>Both rules are illustrated with an example in which there are 3 independent variables \(x,y,z\) and 1 dependent variable \(w=f(x,y,z)\), though the following code readily generalizes to any number of independent variables, limited only by the C++ compiler/memory/platform. The maximum derivative order of each variable is <code>Nx</code>, <code>Ny</code>, and <code>Nz</code>, respectively. Then the type for <code>w</code> is <code>boost::math::differentiation::autodiff::variable&lt;T,Nx,Ny,Nz&gt;</code> and all possible mixed partial derivatives are available via </p><p class="formulaDsp">
\[ {\tt w.derivative(nx,ny,nz)} = \frac{\partial^{n_x+n_y+n_z}f}{\partial x^{n_x}\partial y^{n_y}\partial z^{n_z} }(x_0,y_0,z_0) \qquad \text{for}\; (n_x,n_y,n_z)\in\{0,1,2,...,N_x\}\times\{0,1,2,...,N_y\}\times\{0,1,2,...,N_z\} \]
</p>
<p>where \(x_0, y_0, z_0\) are the numerical values at which the function \(f\) and its derivatives are evaluated.</p>
<p>In code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1math_1_1differentiation.html">boost::math::differentiation</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> var = autodiff::variable&lt;double,Nx,Ny,Nz&gt;; <span class="comment">// Nx, Ny, Nz are constexpr size_t.</span></div><div class="line"></div><div class="line">var x = autodiff::variable&lt;double,Nx&gt;(x0);       <span class="comment">// x0 is of type double</span></div><div class="line">var y = autodiff::variable&lt;double,Nx,Ny&gt;(y0);    <span class="comment">// y0 is of type double</span></div><div class="line">var z = autodiff::variable&lt;double,Nx,Ny,Nz&gt;(z0); <span class="comment">// z0 is of type double</span></div><div class="line"></div><div class="line">var w = f(x,y,z);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> nx=0 ; nx&lt;=Nx ; ++nx)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ny=0 ; ny&lt;=Ny ; ++ny)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> nz=0 ; nz&lt;=Nz ; ++nz)</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;w.derivative(&quot;</span>&lt;&lt;nx&lt;&lt;<span class="charliteral">&#39;,&#39;</span>&lt;&lt;ny&lt;&lt;<span class="charliteral">&#39;,&#39;</span>&lt;&lt;nz&lt;&lt;<span class="stringliteral">&quot;) == &quot;</span> &lt;&lt; w.derivative(nx,ny,nz) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Note how <code>x</code>, <code>y</code>, and <code>z</code> are initialized: the last template parameter determines which variable \(x, y,\) or \(z\) a derivative is taken with respect to. In terms of the \(\varepsilon\)-polynomials above, this determines whether to add \(\varepsilon_x, \varepsilon_y,\) or \(\varepsilon_z\) to \(x_0, y_0,\) or \(z_0\), respectively.</p>
<p>In contrast, the following initialization of <code>x</code> would be INCORRECT: </p><div class="fragment"><div class="line">var x = autodiff::variable&lt;T,Nx,0&gt;(x0); <span class="comment">// WRONG</span></div></div><!-- fragment --><p>Mathematically, this represents \(x_0+\varepsilon_y\), since the last template parameter corresponds to the \(y\) variable, and thus the resulting value will be invalid.</p>
<h3><a class="anchor" id="type-promotion"></a>
Type Promotion</h3>
<p>The previous example can be optimized to save some unnecessary computation, by declaring smaller arrays, and relying on autodiff's automatic type-promotion: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1math_1_1differentiation.html">boost::math::differentiation</a>;</div><div class="line"></div><div class="line">autodiff::variable&lt;double,Nx&gt; x(x0);</div><div class="line">autodiff::variable&lt;double,0,Ny&gt; y(y0);</div><div class="line">autodiff::variable&lt;double,0,0,Nz&gt; z(z0);</div><div class="line"></div><div class="line">autodiff::variable&lt;double,Nx,Ny,Nz&gt; w = f(x,y,z);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> nx=0 ; nx&lt;=Nx ; ++nx)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ny=0 ; ny&lt;=Ny ; ++ny)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> nz=0 ; nz&lt;=Nz ; ++nz)</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;w.derivative(&quot;</span>&lt;&lt;nx&lt;&lt;<span class="charliteral">&#39;,&#39;</span>&lt;&lt;ny&lt;&lt;<span class="charliteral">&#39;,&#39;</span>&lt;&lt;nz&lt;&lt;<span class="stringliteral">&quot;) == &quot;</span> &lt;&lt; w.derivative(nx,ny,nz) &lt;&lt; std::endl;</div></div><!-- fragment --><p>For example, if one of the first steps in the computation of \(f\) was <code>z*z</code>, then a significantly less number of multiplications and additions may occur if <code>z</code> is declared as <code>variable&lt;double,0,0,Nz&gt;</code> as opposed to <code>variable&lt;double,Nx,Ny,Nz&gt;</code>. There is no loss of precision with the former, since the extra dimensions represent 0 values. Once <code>z</code> is combined with <code>x</code> and <code>y</code> during the computation, the types will be promoted as necessary. This is the recommended way to initialize variables in autodiff.</p>
<h1><a class="anchor" id="acknowledgments"></a>
Acknowledgments</h1>
<ul>
<li>Kedar Bhat - C++11 compatibility and feedback.</li>
<li>Nick Thompson - Initial feedback and help with Boost integration.</li>
<li>John Maddock - Initial feedback and help with Boost integration.</li>
</ul>
<dl class="section copyright"><dt>Copyright</dt><dd><center> Copyright &copy; Matthew Pulver 2018 - 2019.<br />
 Distributed under the Boost Software License, Version 1.0.<br />
 (See accompanying file LICENSE_1_0.txt or copy at<br />
 <a href="https://www.boost.org/LICENSE_1_0.txt">https://www.boost.org/LICENSE_1_0.txt</a>) </center> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
